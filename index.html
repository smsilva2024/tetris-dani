<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <title>DANI-TETRIS (HTML5)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body { background: #000; margin: 0; overflow: hidden; color: white; font-family: Arial; text-align: center; }
    canvas { background: black; border: 2px solid white; display: block; margin: auto; }
    .controls { margin-top: 10px; }
    button { margin: 5px; padding: 10px 15px; font-size: 18px; border-radius: 8px; border: none; background: #444; color: white; }
    button:hover { background: #666; }
  </style>
</head>
<body>
<h2 style="color:white">DANI-TETRIS</h2>
<canvas id="tetris" width="330" height="660"></canvas>
<div class="controls">
  <button onclick="move(-1, 0)">‚¨ÖÔ∏è</button>
  <button onclick="rotatePiece()">üîÑ</button>
  <button onclick="move(1, 0)">‚û°Ô∏è</button><br>
  <button onclick="drop()">‚¨áÔ∏è</button>
  <button onclick="hardDrop()">‚è¨</button>
</div>
<script>
const canvas = document.getElementById("tetris");
const ctx = canvas.getContext("2d");
const CELL = 33;
const ROWS = 20;
const COLS = 10;
const COLORS = ["cyan", "yellow", "purple", "blue", "orange", "green", "red"];

const SHAPES = [
  [[1, 1, 1, 1]],
  [[1, 1], [1, 1]],
  [[0, 1, 0], [1, 1, 1]],
  [[1, 0, 0], [1, 1, 1]],
  [[0, 0, 1], [1, 1, 1]],
  [[1, 1, 0], [0, 1, 1]],
  [[0, 1, 1], [1, 1, 0]]
];

let shapeIdxList = [0,0,0,0,0,1,2,3,4,5,6];
let board = [];
let score = 0;
let gameOver = false;
let golfWin = false;
let current, currentColor, pos;
let dropCounter = 0;
let dropInterval = 500;
let lastTime = 0;

function createBoard() {
  board = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
}

function drawCell(x, y, color) {
  ctx.fillStyle = color;
  ctx.fillRect(x * CELL, y * CELL, CELL, CELL);
  ctx.strokeStyle = "gray";
  ctx.strokeRect(x * CELL, y * CELL, CELL, CELL);
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  board.forEach((row, y) => {
    row.forEach((val, x) => {
      if (val) drawCell(x, y, COLORS[val - 1]);
    });
  });
  current.forEach((row, yOffset) => {
    row.forEach((val, xOffset) => {
      if (val) drawCell(pos.x + xOffset, pos.y + yOffset, currentColor);
    });
  });
  ctx.fillStyle = "white";
  ctx.fillText(`Score: ${score}`, 10, 20);
  if (golfWin) showMessage("BOLINHA DE GOLFE!", "green");
  else if (gameOver) showMessage("Game Over!", "red");
}

function showMessage(msg, color) {
  ctx.fillStyle = color;
  ctx.font = "28px Arial";
  ctx.textAlign = "center";
  ctx.fillText(msg, canvas.width / 2, canvas.height / 2);
}

function newPiece() {
  const idx = shapeIdxList[Math.floor(Math.random() * shapeIdxList.length)];
  current = SHAPES[idx].map(r => r.slice());
  currentColor = COLORS[idx];
  pos = { x: Math.floor(COLS / 2) - Math.floor(current[0].length / 2), y: 0 };
  if (!valid(current, pos)) gameOver = true;
}

function rotate(shape) {
  return shape[0].map((_, i) => shape.map(row => row[i]).reverse());
}

function rotatePiece() {
  if (gameOver) return;
  const rotated = rotate(current);
  if (valid(rotated, pos)) current = rotated;
}

function valid(shape, p) {
  return shape.every((row, y) => {
    return row.every((val, x) => {
      if (!val) return true;
      const xx = p.x + x, yy = p.y + y;
      return yy >= 0 && yy < ROWS && xx >= 0 && xx < COLS && !board[yy][xx];
    });
  });
}

function fixPiece() {
  current.forEach((row, y) => {
    row.forEach((val, x) => {
      if (val) board[pos.y + y][pos.x + x] = COLORS.indexOf(currentColor) + 1;
    });
  });
  clearLines();
  checkGolfWin();
  newPiece();
}

function clearLines() {
  let lines = 0;
  board = board.filter(row => {
    if (row.some(cell => cell === 0)) return true;
    lines++;
    return false;
  });
  while (board.length < ROWS) board.unshift(Array(COLS).fill(0));
  score += lines * 100;
}

function checkGolfWin() {
  for (let x = 0; x < COLS; x++) {
    let count = 0;
    for (let y = 0; y < ROWS; y++) {
      if (board[y][x] === 2) count++;
    }
    if (count >= 6) {
      golfWin = true;
      gameOver = true;
      break;
    }
  }
}

function drop() {
  if (!move(0, 1)) fixPiece();
  dropCounter = 0;
}

function hardDrop() {
  while (move(0, 1)) {}
  fixPiece();
}

function move(dx, dy) {
  const newPos = { x: pos.x + dx, y: pos.y + dy };
  if (valid(current, newPos)) {
    pos = newPos;
    return true;
  }
  return false;
}

function update(time = 0) {
  const delta = time - lastTime;
  lastTime = time;
  dropCounter += delta;
  if (dropCounter > dropInterval && !gameOver) drop();
  draw();
  requestAnimationFrame(update);
}

function restart() {
  createBoard();
  score = 0;
  gameOver = false;
  golfWin = false;
  newPiece();
}

document.addEventListener("keydown", e => {
  if (gameOver) return;
  if (e.key === "ArrowLeft") move(-1, 0);
  else if (e.key === "ArrowRight") move(1, 0);
  else if (e.key === "ArrowDown") drop();
  else if (e.key === "ArrowUp") rotatePiece();
  else if (e.code === "Space") hardDrop();
});

restart();
update();
</script>
</body>
</html>
